#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Resource Registry Builder

Scans resources/ directory and builds RESOURCE-REGISTRY.yaml for agent discovery.
Similar to tool registry, but for reference materials (PDFs, frameworks, benchmarks).

This runs as a startup hook to ensure agents are aware of all available resources.

Usage:
    python tools/validation/build-resource-registry.py

Output:
    library/catalogs/RESOURCE-REGISTRY.yaml - Machine-readable registry
    library/catalogs/RESOURCES-CATALOG.md - Human-readable catalog

Author: Intelligence Adjacent Framework
Date: 2025-12-12
Version: 1.0
"""

import os
import sys
import yaml
import json
from pathlib import Path
from datetime import datetime
from collections import defaultdict

# Fix Windows console encoding
if sys.platform == "win32":
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stdin.reconfigure(encoding='utf-8')

# Paths
FRAMEWORK_ROOT = Path(__file__).parent.parent.parent
RESOURCES_DIR = FRAMEWORK_ROOT / "resources"
REGISTRY_PATH = FRAMEWORK_ROOT / "library" / "catalogs" / "RESOURCE-REGISTRY.yaml"
CATALOG_PATH = FRAMEWORK_ROOT / "library" / "catalogs" / "RESOURCES-CATALOG.md"


def load_manifest(manifest_path):
    """
    Load resource manifest.yaml file.

    Args:
        manifest_path (Path): Path to manifest.yaml

    Returns:
        dict: Manifest data or None if not found/invalid
    """
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        return None
    except yaml.YAMLError as e:
        print(f"âš ï¸  Invalid YAML in {manifest_path}: {e}")
        return None


def load_metadata(metadata_path):
    """
    Load metadata.json file (generated by PDF splitter).

    Args:
        metadata_path (Path): Path to metadata.json

    Returns:
        dict: Metadata or None if not found/invalid
    """
    try:
        with open(metadata_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return None
    except json.JSONDecodeError as e:
        print(f"âš ï¸  Invalid JSON in {metadata_path}: {e}")
        return None


def scan_resources_directory():
    """
    Scan resources/ directory for all resource manifests and metadata.

    Returns:
        dict: Registry data structure
    """
    print(f"ğŸ“‚ Scanning: {RESOURCES_DIR}")

    if not RESOURCES_DIR.exists():
        print(f"âš ï¸  Resources directory not found: {RESOURCES_DIR}")
        print(f"   Creating empty registry...")
        return {
            "generated": datetime.now().isoformat(),
            "resources_path": str(RESOURCES_DIR),
            "total_documents": 0,
            "total_categories": 0,
            "by_skill": {},
            "by_category": {},
            "resources": []
        }

    resources = []
    by_skill = defaultdict(list)
    by_category = defaultdict(lambda: defaultdict(int))

    # Find all manifest.yaml files
    manifest_files = list(RESOURCES_DIR.rglob("manifest.yaml"))

    # If no manifests, scan for metadata.json files (migration in progress)
    if not manifest_files:
        print(f"   No manifest.yaml files found, scanning for metadata.json...")
        metadata_files = list(RESOURCES_DIR.rglob("metadata.json"))

        for metadata_path in metadata_files:
            metadata = load_metadata(metadata_path)
            if not metadata:
                continue

            resource_dir = metadata_path.parent

            # Count split files
            pages_dir = resource_dir / "pages"
            splits = len(list(pages_dir.glob("*.pdf"))) if pages_dir.exists() else 0

            # Extract category from path
            rel_path = resource_dir.relative_to(RESOURCES_DIR)
            category = "/".join(rel_path.parts[:3]) if len(rel_path.parts) >= 3 else "uncategorized"

            resource_entry = {
                "name": metadata.get("original_filename", resource_dir.name),
                "type": "document",  # Generic type
                "path": str(rel_path),
                "pages": metadata.get("total_pages", 0),
                "splits": splits,
                "sha256": metadata.get("sha256", ""),
                "has_manifest": False,
                "category": category
            }

            resources.append(resource_entry)
            by_category[category]["total"] += 1

    else:
        # Process manifest files
        for manifest_path in manifest_files:
            manifest = load_manifest(manifest_path)
            if not manifest:
                continue

            resource_dir = manifest_path.parent

            # Load metadata.json if exists
            metadata_path = resource_dir / "metadata.json"
            metadata = load_metadata(metadata_path)

            # Count split files
            pages_dir = resource_dir / "pages"
            splits = len(list(pages_dir.glob("*.pdf"))) if pages_dir.exists() else 0

            # Extract category from path
            rel_path = resource_dir.relative_to(RESOURCES_DIR)
            parts = rel_path.parts

            # Determine category (e.g., library/benchmarks/cis)
            if len(parts) >= 3:
                category = "/".join(parts[:3])
            else:
                category = "uncategorized"

            resource_entry = {
                "name": manifest.get("name", resource_dir.name),
                "type": manifest.get("type", "document"),
                "path": str(rel_path),
                "version": manifest.get("version"),
                "provider": manifest.get("provider"),
                "platform": manifest.get("platform"),
                "pages": metadata.get("total_pages") if metadata else manifest.get("pages"),
                "splits": splits,
                "sha256": metadata.get("sha256") if metadata else None,
                "skills": manifest.get("skills", []),
                "source_url": manifest.get("source_url"),
                "description": manifest.get("description", "").strip(),
                "has_manifest": True,
                "category": category
            }

            resources.append(resource_entry)

            # Index by skill
            for skill in manifest.get("skills", []):
                by_skill[skill].append(resource_entry)

            # Index by category
            by_category[category][manifest.get("type", "document")] += 1

    print(f"   Found {len(resources)} resources")
    print(f"   Categories: {len(by_category)}")
    print(f"   Skills referenced: {len(by_skill)}")

    return {
        "generated": datetime.now().isoformat(),
        "resources_path": str(RESOURCES_DIR),
        "total_documents": len(resources),
        "total_categories": len(by_category),
        "by_skill": dict(by_skill),
        "by_category": {k: dict(v) for k, v in by_category.items()},
        "resources": resources
    }


def build_yaml_registry(registry_data):
    """
    Build YAML registry file.

    Args:
        registry_data (dict): Registry data
    """
    print(f"ğŸ“ Writing: {REGISTRY_PATH}")

    # Ensure directory exists
    REGISTRY_PATH.parent.mkdir(parents=True, exist_ok=True)

    with open(REGISTRY_PATH, 'w', encoding='utf-8') as f:
        yaml.dump(registry_data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)

    print(f"   âœ… RESOURCE-REGISTRY.yaml created ({len(registry_data['resources'])} resources)")


def build_markdown_catalog(registry_data):
    """
    Build human-readable markdown catalog.

    Args:
        registry_data (dict): Registry data
    """
    print(f"ğŸ“ Writing: {CATALOG_PATH}")

    lines = [
        "# Resources Catalog",
        "",
        f"**Auto-generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}",
        f"**Total Documents:** {registry_data['total_documents']}",
        f"**Categories:** {registry_data['total_categories']}",
        "",
        "---",
        ""
    ]

    # Summary by skill
    if registry_data['by_skill']:
        lines.append("## Resources by Skill")
        lines.append("")

        for skill, resources in sorted(registry_data['by_skill'].items()):
            lines.append(f"### {skill}")
            lines.append(f"**Total:** {len(resources)} documents")
            lines.append("")

            for resource in resources[:10]:  # Limit to first 10
                lines.append(f"- **{resource['name']}**")
                if resource.get('version'):
                    lines.append(f"  - Version: {resource['version']}")
                if resource.get('pages'):
                    lines.append(f"  - Pages: {resource['pages']} ({resource.get('splits', 0)} splits)")
                lines.append(f"  - Path: `{resource['path']}`")
                lines.append("")

            if len(resources) > 10:
                lines.append(f"  ... and {len(resources) - 10} more")
                lines.append("")

        lines.append("---")
        lines.append("")

    # Summary by category
    if registry_data['by_category']:
        lines.append("## Resources by Category")
        lines.append("")

        for category, types in sorted(registry_data['by_category'].items()):
            total = sum(types.values())
            lines.append(f"### {category}")
            lines.append(f"**Total:** {total} documents")
            lines.append("")

            for doc_type, count in sorted(types.items()):
                lines.append(f"- {doc_type}: {count}")

            lines.append("")

        lines.append("---")
        lines.append("")

    # All resources (condensed)
    lines.append("## All Resources")
    lines.append("")
    lines.append("| Name | Type | Pages | Splits | Skills |")
    lines.append("|------|------|-------|--------|--------|")

    for resource in sorted(registry_data['resources'], key=lambda x: x.get('name', '')):
        name = resource.get('name', 'Unknown')
        res_type = resource.get('type', 'document')
        pages = resource.get('pages', 0)
        splits = resource.get('splits', 0)
        skills = ", ".join(resource.get('skills', []))[:30]  # Truncate if long

        lines.append(f"| {name[:40]} | {res_type} | {pages} | {splits} | {skills} |")

    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append(f"**Generated:** {datetime.now().isoformat()}")
    lines.append(f"**Framework:** Intelligence Adjacent (IA)")

    with open(CATALOG_PATH, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))

    print(f"   âœ… RESOURCES-CATALOG.md created")


def main():
    """Main execution."""
    print("=" * 60)
    print("Resource Registry Builder")
    print("=" * 60)
    print()

    # Scan resources
    registry_data = scan_resources_directory()

    # Build YAML registry
    build_yaml_registry(registry_data)

    # Build markdown catalog
    build_markdown_catalog(registry_data)

    print()
    print("=" * 60)
    print("âœ… Resource registry build complete!")
    print()
    print(f"   ğŸ“Š Total resources: {registry_data['total_documents']}")
    print(f"   ğŸ“ Categories: {registry_data['total_categories']}")
    print(f"   ğŸ”§ Skills: {len(registry_data['by_skill'])}")
    print()
    print("   Registry: library/catalogs/RESOURCE-REGISTRY.yaml")
    print("   Catalog:  library/catalogs/RESOURCES-CATALOG.md")
    print("=" * 60)

    return 0


if __name__ == "__main__":
    sys.exit(main())
