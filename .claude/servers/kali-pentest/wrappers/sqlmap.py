#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
sqlmap wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes sqlmap, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def sqlmap(url: str, options: str = "--batch --random-agent", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute sqlmap SQL injection detection and exploitation.

    Args:
        url: Target URL with parameters
        options: Additional sqlmap options (default: --batch --random-agent)
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (injection points, database info)
        - outputFile: Path to raw sqlmap output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    from urllib.parse import urlparse
    parsed = urlparse(url)
    safe_domain = parsed.netloc.replace(":", "_") if parsed.netloc else url.replace("/", "_").replace(":", "_")
    filename = f"{safe_domain}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "04-exploitation" / "sqlmap"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "sqlmap"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute sqlmap
    cmd = f"sqlmap -u {url} {options} > {output_file} 2>&1"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            timeout=1800  # 30 minute timeout
        )

        # sqlmap may return non-zero even with findings
        if not output_file.exists():
            return {
                "error": "sqlmap execution failed - no output file created",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_sqlmap_output(output_file)

        # Generate message
        message = f"[+] sqlmap scan complete\n"
        message += f"    Target: {url}\n"

        if summary["vulnerable"]:
            message += f"    [ALERT] SQL injection FOUND\n"
            message += f"    Vulnerable parameters: {len(summary['vulnerableParameters'])}\n"

            if summary["vulnerableParameters"]:
                message += f"    Parameters:\n"
                for param in summary["vulnerableParameters"][:5]:
                    message += f"      - {param['parameter']} ({param['type']})\n"

            if summary["databaseInfo"]:
                message += f"    Database info:\n"
                if summary["databaseInfo"].get("dbms"):
                    message += f"      DBMS: {summary['databaseInfo']['dbms']}\n"
                if summary["databaseInfo"].get("version"):
                    message += f"      Version: {summary['databaseInfo']['version']}\n"
                if summary["databaseInfo"].get("currentUser"):
                    message += f"      User: {summary['databaseInfo']['currentUser']}\n"
        else:
            message += f"    No SQL injection vulnerabilities found\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "sqlmap timed out (30 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"sqlmap execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_sqlmap_output(filepath: Path) -> Dict:
    """Parse sqlmap text output file."""

    if not filepath.exists():
        return {
            "vulnerable": False,
            "vulnerableParameters": [],
            "databaseInfo": {}
        }

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    vulnerable = False
    vulnerable_params = []
    db_info = {}

    # Check if vulnerable
    if "is vulnerable" in content.lower() or "parameter '" in content and "is vulnerable" in content:
        vulnerable = True

    # Extract vulnerable parameters
    param_pattern = r"Parameter: ([^\s]+) \(([^)]+)\).*?Type: ([^\n]+)"
    for match in re.finditer(param_pattern, content, re.DOTALL):
        vulnerable_params.append({
            "parameter": match.group(1),
            "location": match.group(2),
            "type": match.group(3).strip()
        })

    # Extract database info
    dbms_match = re.search(r"back-end DBMS:\s*([^\n]+)", content, re.IGNORECASE)
    if dbms_match:
        db_info["dbms"] = dbms_match.group(1).strip()

    version_match = re.search(r"back-end DBMS.*?:\s*([^\n]+)", content)
    if version_match:
        db_info["version"] = version_match.group(1).strip()

    user_match = re.search(r"current user:\s*'([^']+)'", content, re.IGNORECASE)
    if user_match:
        db_info["currentUser"] = user_match.group(1)

    db_match = re.search(r"current database:\s*'([^']+)'", content, re.IGNORECASE)
    if db_match:
        db_info["currentDatabase"] = db_match.group(1)

    return {
        "vulnerable": vulnerable,
        "vulnerableParameters": vulnerable_params,
        "databaseInfo": db_info
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python sqlmap.py <url> [options] [engagement_dir]")
        print("Example: python sqlmap.py 'https://example.com/page?id=1'")
        print("Example: python sqlmap.py 'https://example.com/page?id=1' '--dbs --dump'")
        sys.exit(1)

    url = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else "--batch --random-agent"
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = sqlmap(url, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
