#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
searchsploit wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes searchsploit, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def searchsploit(query: str, options: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute searchsploit ExploitDB search.

    Args:
        query: Search query
        options: Additional searchsploit options
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (exploit count, categories)
        - outputFile: Path to raw searchsploit output
        - message: Human-readable summary (returns direct output for this tool)
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    safe_query = re.sub(r'[^\w\-]', '_', query)
    filename = f"{safe_query}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "02-reconnaissance" / "searchsploit"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "searchsploit"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute searchsploit
    cmd = f"searchsploit {options} {query}"

    try:
        result = docker_exec("kali-pentest", cmd, timeout=60)

        # Save output to file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(result["stdout"])

        # Parse the output
        summary = parse_searchsploit_output(result["stdout"])

        # Generate message (searchsploit is already concise, return mostly direct)
        message = f"[+] searchsploit query complete\n"
        message += f"    Query: {query}\n"
        message += f"    Exploits found: {summary['exploitCount']}\n"

        if summary["platforms"]:
            message += f"    Platforms:\n"
            for platform, count in sorted(summary["platforms"].items(), key=lambda x: x[1], reverse=True)[:5]:
                message += f"      {platform}: {count}\n"

        if summary["sampleExploits"]:
            message += f"    Sample exploits (first 5):\n"
            for exploit in summary["sampleExploits"][:5]:
                message += f"      {exploit['title']} | {exploit['path']}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "searchsploit timed out (60 seconds)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"searchsploit execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_searchsploit_output(output: str) -> Dict:
    """Parse searchsploit output."""

    exploits = []
    platforms = {}

    # Split output into lines
    lines = output.split('\n')

    for line in lines:
        line = line.strip()
        if not line or line.startswith('-') or 'Exploit Title' in line:
            continue

        # searchsploit format: Title | Path
        if '|' in line:
            parts = line.split('|')
            if len(parts) >= 2:
                title = parts[0].strip()
                path = parts[1].strip()

                exploits.append({
                    "title": title,
                    "path": path
                })

                # Extract platform from path (e.g., exploits/linux/local/...)
                path_parts = path.split('/')
                if len(path_parts) >= 2:
                    platform = path_parts[1]
                    platforms[platform] = platforms.get(platform, 0) + 1

    return {
        "exploitCount": len(exploits),
        "platforms": platforms,
        "sampleExploits": exploits[:20]  # First 20 for sample
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python searchsploit.py <query> [options] [engagement_dir]")
        print("Example: python searchsploit.py 'apache 2.4'")
        print("Example: python searchsploit.py wordpress '--exclude=\"/dos/\"'")
        sys.exit(1)

    query = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else ""
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = searchsploit(query, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
