#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
dirb wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes dirb, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def dirb(url: str, wordlist: str = "/usr/share/dirb/wordlists/common.txt", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute dirb directory brute forcing.

    Args:
        url: Target URL
        wordlist: Wordlist file path (default: /usr/share/dirb/wordlists/common.txt)
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (discovered paths by status code)
        - outputFile: Path to raw dirb output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    from urllib.parse import urlparse
    parsed = urlparse(url)
    safe_domain = parsed.netloc.replace(":", "_") if parsed.netloc else url.replace("/", "_").replace(":", "_")
    filename = f"{safe_domain}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "04-exploitation" / "dirb"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "dirb"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute dirb
    cmd = f"dirb {url} {wordlist} -o {output_file}"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=1800  # 30 minute timeout
        )

        if result["returncode"] != 0 and not output_file.exists():
            return {
                "error": f"dirb execution failed: {result["stderr"]}",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_dirb_output(output_file)

        # Generate message
        total = summary["totalPaths"]
        message = f"[+] dirb scan complete\n"
        message += f"    Target: {url}\n"
        message += f"    Wordlist: {wordlist}\n"
        message += f"    Paths discovered: {total}\n"

        if summary["byStatus"]:
            message += f"    By status code:\n"
            for status, count in sorted(summary["byStatus"].items()):
                message += f"      {status}: {count}\n"

        if summary["interestingPaths"]:
            message += f"    Interesting paths (200/301/403):\n"
            for path_info in summary["interestingPaths"][:10]:
                message += f"      [{path_info['status']}] {path_info['path']}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "dirb timed out (30 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"dirb execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_dirb_output(filepath: Path) -> Dict:
    """Parse dirb output file."""

    if not filepath.exists():
        return {
            "totalPaths": 0,
            "byStatus": {},
            "interestingPaths": []
        }

    paths = []
    by_status = {}

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Extract discovered paths
    # Format: + URL (CODE:STATUS|SIZE:BYTES)
    path_pattern = r"\+ (.+?) \(CODE:(\d+)\|SIZE:(\d+)\)"
    for match in re.finditer(path_pattern, content):
        url = match.group(1)
        status = match.group(2)
        size = match.group(3)

        paths.append({
            "path": url,
            "status": status,
            "size": size
        })

        # Count by status
        by_status[status] = by_status.get(status, 0) + 1

    # Filter interesting paths (200, 301, 403)
    interesting = [
        p for p in paths
        if p["status"] in ["200", "301", "403"]
    ]

    return {
        "totalPaths": len(paths),
        "byStatus": by_status,
        "interestingPaths": interesting
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python dirb.py <url> [wordlist] [engagement_dir]")
        print("Example: python dirb.py https://example.com")
        print("Example: python dirb.py https://example.com /usr/share/wordlists/dirb/big.txt")
        sys.exit(1)

    url = sys.argv[1]
    wordlist = sys.argv[2] if len(sys.argv) > 2 else "/usr/share/dirb/wordlists/common.txt"
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = dirb(url, wordlist, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
