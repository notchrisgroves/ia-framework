#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
crackmapexec wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes crackmapexec, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def crackmapexec(target: str, protocol: str = "smb", username: str = "", password: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute crackmapexec for Windows network reconnaissance.

    Args:
        target: Target IP/hostname/CIDR
        protocol: Protocol to use (smb, winrm, ssh, etc.)
        username: Username for authentication
        password: Password for authentication
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (hosts, credentials, shares)
        - outputFile: Path to raw crackmapexec output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    safe_target = target.replace("/", "_").replace(":", "_")
    filename = f"{safe_target}-{protocol}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "05-post-exploitation" / "crackmapexec"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "crackmapexec"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Build command
    cmd = f"crackmapexec {protocol} {target}"
    if username and password:
        cmd += f" -u {username} -p {password}"
    cmd += f" > {output_file} 2>&1"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            timeout=600  # 10 minute timeout
        )

        if not output_file.exists():
            return {
                "error": "crackmapexec execution failed - no output file created",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_crackmapexec_output(output_file)

        # Generate message
        message = f"[+] crackmapexec scan complete\n"
        message += f"    Target: {target}\n"
        message += f"    Protocol: {protocol}\n"
        message += f"    Hosts found: {summary['hostCount']}\n"

        if summary["authenticatedHosts"]:
            message += f"    [ALERT] Authenticated: {len(summary['authenticatedHosts'])}\n"
            for host_info in summary["authenticatedHosts"][:5]:
                message += f"      {host_info['host']} ({host_info['os']})\n"

        if summary["shares"]:
            message += f"    Shares discovered: {len(summary['shares'])}\n"
            for share in summary["shares"][:5]:
                message += f"      \\\\{share['host']}\\{share['share']}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "crackmapexec timed out (10 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"crackmapexec execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_crackmapexec_output(filepath: Path) -> Dict:
    """Parse crackmapexec output file."""

    if not filepath.exists():
        return {
            "hostCount": 0,
            "authenticatedHosts": [],
            "shares": []
        }

    hosts = set()
    authenticated_hosts = []
    shares = []

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Extract hosts
    # Format: SMB 192.168.1.1 445 HOSTNAME [OS info]
    host_pattern = r"SMB\s+([\d\.]+)\s+\d+\s+(\S+)\s+\[(.+?)\]"
    for match in re.finditer(host_pattern, content):
        ip = match.group(1)
        hostname = match.group(2)
        os_info = match.group(3)

        hosts.add(ip)

        # Check for authentication success
        if "(Pwn3d!)" in content or "STATUS_SUCCESS" in content:
            authenticated_hosts.append({
                "host": ip,
                "hostname": hostname,
                "os": os_info
            })

    # Extract shares
    # Format: SMB 192.168.1.1 445 HOSTNAME [+] \\HOSTNAME\SHARE
    share_pattern = r"\[\+\]\s+\\\\(\S+?)\\(\S+)"
    for match in re.finditer(share_pattern, content):
        host = match.group(1)
        share = match.group(2)

        shares.append({
            "host": host,
            "share": share
        })

    return {
        "hostCount": len(hosts),
        "authenticatedHosts": authenticated_hosts,
        "shares": shares
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python crackmapexec.py <target> [protocol] [username] [password] [engagement_dir]")
        print("Example: python crackmapexec.py 192.168.1.0/24")
        print("Example: python crackmapexec.py 192.168.1.1 smb administrator password123")
        sys.exit(1)

    target = sys.argv[1]
    protocol = sys.argv[2] if len(sys.argv) > 2 else "smb"
    username = sys.argv[3] if len(sys.argv) > 3 else ""
    password = sys.argv[4] if len(sys.argv) > 4 else ""
    engagement_dir = sys.argv[5] if len(sys.argv) > 5 else None

    result = crackmapexec(target, protocol, username, password, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
