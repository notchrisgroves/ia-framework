#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
hydra wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes hydra, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def hydra(target: str, service: str = "ssh", username: str = "", password_file: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute hydra password brute forcing.

    Args:
        target: Target IP/hostname
        service: Service to attack (ssh, ftp, http-get, etc.)
        username: Username to test (or file with -L)
        password_file: Password wordlist file path
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (valid credentials found)
        - outputFile: Path to raw hydra output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    safe_target = target.replace("/", "_").replace(":", "_")
    filename = f"{safe_target}-{service}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "04-exploitation" / "hydra"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "hydra"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Build command
    if not username or not password_file:
        return {
            "error": "Both username and password_file are required",
            "outputFile": str(output_file)
        }

    cmd = f"hydra -l {username} -P {password_file} {target} {service} -o {output_file}"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=3600  # 60 minute timeout
        )

        # hydra returns non-zero if no credentials found
        if not output_file.exists():
            return {
                "error": f"hydra execution failed: {result["stderr"]}",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_hydra_output(output_file)

        # Generate message
        message = f"[+] hydra brute force complete\n"
        message += f"    Target: {target}\n"
        message += f"    Service: {service}\n"
        message += f"    Username: {username}\n"

        if summary["credentialsFound"]:
            message += f"    [ALERT] Valid credentials FOUND: {len(summary['credentials'])}\n"
            for cred in summary["credentials"]:
                message += f"      {cred['username']}:{cred['password']}\n"
        else:
            message += f"    No valid credentials found\n"

        if summary["attempts"]:
            message += f"    Attempts: {summary['attempts']}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "hydra timed out (60 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"hydra execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_hydra_output(filepath: Path) -> Dict:
    """Parse hydra output file."""

    if not filepath.exists():
        return {
            "credentialsFound": False,
            "credentials": [],
            "attempts": 0
        }

    credentials = []
    attempts = 0

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Extract valid credentials
    # Format: [PORT][SERVICE] host: IP   login: USER   password: PASS
    cred_pattern = r"\[.*?\]\[.*?\]\s+host:\s+[\d\.]+\s+login:\s+(\S+)\s+password:\s+(\S+)"
    for match in re.finditer(cred_pattern, content):
        credentials.append({
            "username": match.group(1),
            "password": match.group(2)
        })

    # Extract attempt count
    attempt_match = re.search(r"(\d+) attempts", content)
    if attempt_match:
        attempts = int(attempt_match.group(1))

    return {
        "credentialsFound": len(credentials) > 0,
        "credentials": credentials,
        "attempts": attempts
    }


if __name__ == "__main__":
    if len(sys.argv) < 4:
        print("Usage: python hydra.py <target> <service> <username> <password_file> [engagement_dir]")
        print("Example: python hydra.py 192.168.1.1 ssh admin /usr/share/wordlists/rockyou.txt")
        print("Example: python hydra.py example.com ftp user passwords.txt")
        sys.exit(1)

    target = sys.argv[1]
    service = sys.argv[2]
    username = sys.argv[3]
    password_file = sys.argv[4]
    engagement_dir = sys.argv[5] if len(sys.argv) > 5 else None

    result = hydra(target, service, username, password_file, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
