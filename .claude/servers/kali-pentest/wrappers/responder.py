#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
responder wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes responder, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def responder(interface: str = "eth0", options: str = "-I", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute responder LLMNR/NBT-NS/MDNS poisoner.

    Args:
        interface: Network interface to use
        options: Responder options (default: -I for analyze mode)
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (captured hashes, credentials)
        - outputFile: Path to raw responder output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    filename = f"responder-{interface}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "05-post-exploitation" / "responder"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "responder"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute responder (note: typically requires root/admin)
    cmd = f"responder {options} {interface} > {output_file} 2>&1"

    try:
        # Note: responder is a long-running tool, shorter timeout for testing
        result = subprocess.run(
            cmd,
            shell=True,
            timeout=300  # 5 minute timeout for capture
        )

        if not output_file.exists():
            return {
                "error": "responder execution failed - no output file created",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_responder_output(output_file)

        # Generate message
        message = f"[+] responder capture complete\n"
        message += f"    Interface: {interface}\n"
        message += f"    Duration: 5 minutes\n"

        if summary["hashescaptured"]:
            message += f"    [ALERT] Hashes captured: {len(summary['hashes'])}\n"
            for hash_info in summary["hashes"][:5]:
                message += f"      {hash_info['type']}: {hash_info['username']}@{hash_info['host']}\n"

        if summary["poisonEvents"]:
            message += f"    Poison events: {summary['poisonEvents']}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        # This is expected for responder - capture completed
        if output_file.exists():
            summary = parse_responder_output(output_file)
            return {
                "summary": summary,
                "outputFile": str(output_file),
                "message": f"Responder capture completed (5 min timeout). Check {output_file} for results."
            }
        else:
            return {
                "error": "responder timed out with no output",
                "outputFile": str(output_file)
            }
    except Exception as e:
        return {
            "error": f"responder execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_responder_output(filepath: Path) -> Dict:
    """Parse responder output file."""

    if not filepath.exists():
        return {
            "hashesCapture": False,
            "hashes": [],
            "poisonEvents": 0
        }

    hashes = []
    poison_events = 0

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Extract captured hashes
    # Format varies by hash type (NTLMv2, NTLMv1, etc.)
    hash_pattern = r"\[(\w+)\]\s+NTLMv\d.*?::([^:]+):.*?:([^:]+)"
    for match in re.finditer(hash_pattern, content):
        hash_type = match.group(1)
        username = match.group(2)
        host = match.group(3)

        hashes.append({
            "type": hash_type,
            "username": username,
            "host": host
        })

    # Count poison events
    poison_events = content.count("[*] Poisoned answer")

    return {
        "hashesCapture": len(hashes) > 0,
        "hashes": hashes,
        "poisonEvents": poison_events
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python responder.py <interface> [options] [engagement_dir]")
        print("Example: python responder.py eth0")
        print("Example: python responder.py wlan0 '-I -v'")
        print("Note: Responder typically requires root/admin privileges")
        sys.exit(1)

    interface = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else "-I"
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = responder(interface, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
