#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
httpx wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes httpx, saves raw output, returns parsed summary
"""

import sys
import io
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def httpx(target: str, options: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute httpx HTTP probing and analysis.

    Args:
        target: Target URL/domain/file with list of hosts
        options: Additional httpx options
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (live hosts, status codes, titles)
        - outputFile: Path to raw httpx output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    safe_target = target.replace("/", "_").replace(":", "_").replace(".", "_")
    filename = f"{safe_target}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "02-reconnaissance" / "httpx"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "httpx"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute httpx
    cmd = f"httpx {options} -u {target} -o {output_file}"

    try:
        result = docker_exec("kali-pentest", cmd, timeout=300)

        if result["returncode"] != 0 and not output_file.exists():
            return {
                "error": f"httpx execution failed: {result["stderr"]}",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_httpx_output(output_file)

        # Generate message
        total = summary["totalHosts"]
        message = f"[+] httpx probe complete\n"
        message += f"    Target: {target}\n"
        message += f"    Live hosts: {total}\n"

        if summary["statusCodes"]:
            message += f"    Status codes:\n"
            for code, count in sorted(summary["statusCodes"].items()):
                message += f"      {code}: {count}\n"

        if summary["sampleHosts"]:
            message += f"    Sample hosts (first 10):\n"
            for host in summary["sampleHosts"][:10]:
                message += f"      - {host['url']} [{host['status']}] {host.get('title', '')}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "httpx timed out (5 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"httpx execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_httpx_output(filepath: Path) -> Dict:
    """Parse httpx output file."""

    if not filepath.exists():
        return {
            "totalHosts": 0,
            "statusCodes": {},
            "sampleHosts": []
        }

    hosts = []
    status_codes = {}

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            # Parse httpx output format: URL [STATUS_CODE] [TITLE]
            parts = line.split()
            if len(parts) >= 2:
                url = parts[0]
                status = parts[1].strip('[]')
                title = ' '.join(parts[2:]).strip('[]') if len(parts) > 2 else ""

                hosts.append({
                    "url": url,
                    "status": status,
                    "title": title
                })

                # Count status codes
                status_codes[status] = status_codes.get(status, 0) + 1

    return {
        "totalHosts": len(hosts),
        "statusCodes": status_codes,
        "sampleHosts": hosts[:20]  # First 20 for sample
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python httpx.py <target> [options] [engagement_dir]")
        print("Example: python httpx.py example.com")
        sys.exit(1)

    target = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else ""
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = httpx(target, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
