#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
wapiti wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes wapiti, saves raw output, returns parsed summary
"""

import sys
import io
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def wapiti(url: str, options: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute wapiti web application vulnerability scanning.

    Args:
        url: Target URL to scan
        options: Additional wapiti options
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (vulnerability types, levels)
        - outputFile: Path to raw wapiti output (JSON format)
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    from urllib.parse import urlparse
    parsed = urlparse(url)
    safe_domain = parsed.netloc.replace(":", "_") if parsed.netloc else url.replace("/", "_").replace(":", "_")
    filename = f"{safe_domain}-{timestamp}.json"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "03-vulnerability-assessment" / "wapiti"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "wapiti"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute wapiti with JSON output
    cmd = f"wapiti -u {url} {options} -f json -o {output_file}"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=1800  # 30 minute timeout for thorough scans
        )

        if result["returncode"] != 0 and not output_file.exists():
            return {
                "error": f"wapiti execution failed: {result["stderr"]}",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_wapiti_output(output_file)

        # Generate message
        total = summary["totalVulnerabilities"]
        message = f"[+] wapiti scan complete\n"
        message += f"    Target: {url}\n"
        message += f"    Vulnerabilities found: {total}\n"

        if summary["byLevel"]:
            message += f"    By level:\n"
            for level in ['high', 'medium', 'low']:
                if level in summary["byLevel"]:
                    message += f"      {level.upper()}: {summary['byLevel'][level]}\n"

        if summary["byType"]:
            message += f"    By type:\n"
            for vuln_type, count in sorted(summary["byType"].items(), key=lambda x: x[1], reverse=True)[:5]:
                message += f"      {vuln_type}: {count}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "wapiti timed out (30 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"wapiti execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_wapiti_output(filepath: Path) -> Dict:
    """Parse wapiti JSON output file."""

    if not filepath.exists():
        return {
            "totalVulnerabilities": 0,
            "byLevel": {},
            "byType": {},
            "topFindings": []
        }

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError:
        return {
            "totalVulnerabilities": 0,
            "byLevel": {},
            "byType": {},
            "topFindings": []
        }

    vulnerabilities = data.get('vulnerabilities', {})
    by_level = {}
    by_type = {}
    top_findings = []
    total = 0

    for vuln_type, instances in vulnerabilities.items():
        if not instances:
            continue

        by_type[vuln_type] = len(instances)
        total += len(instances)

        for instance in instances[:3]:  # Top 3 per type
            level = instance.get('level', 'unknown')
            by_level[level] = by_level.get(level, 0) + 1

            top_findings.append({
                "type": vuln_type,
                "level": level,
                "path": instance.get('path', ''),
                "parameter": instance.get('parameter', '')
            })

    return {
        "totalVulnerabilities": total,
        "byLevel": by_level,
        "byType": by_type,
        "topFindings": top_findings[:20]  # Top 20 overall
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python wapiti.py <url> [options] [engagement_dir]")
        print("Example: python wapiti.py https://example.com")
        print("Example: python wapiti.py https://example.com '-m xss,sql'")
        sys.exit(1)

    url = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else ""
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = wapiti(url, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
