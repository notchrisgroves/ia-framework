#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ffuf wrapper - MCP Code API Pattern (VPS Docker deployment)
Fast web fuzzer for directory/file discovery, parameter fuzzing, and more
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def ffuf(target: str, wordlist: str = "/usr/share/wordlists/dirb/common.txt",
         options: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute ffuf fuzzing on VPS and return parsed summary.

    Args:
        target: Target URL with FUZZ keyword (e.g., https://example.com/FUZZ)
        wordlist: Path to wordlist on VPS container (default: dirb common.txt)
        options: Additional ffuf options (e.g., "-mc 200,301 -t 50")
        engagement_dir: Optional engagement directory path
                       If provided, saves to engagement/02-reconnaissance/ffuf/
                       If None, saves to sessions/[date]/scans/ffuf/

    Returns:
        Dict with:
        - summary: Parsed findings (discovered paths, status codes)
        - outputFile: Path to raw ffuf output (local)
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    # Extract domain from URL for filename
    domain = re.sub(r'https?://', '', target).split('/')[0].replace(':', '_')
    filename = f"{domain}-{timestamp}.txt"

    # Determine output directory (local storage)
    if engagement_dir:
        output_dir = Path(engagement_dir) / "02-reconnaissance" / "ffuf"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "ffuf"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Build ffuf command
    # Use -c for colorless output (cleaner parsing)
    cmd = f"ffuf -u {target} -w {wordlist} -c {options}"

    try:
        result = docker_exec("kali-pentest", cmd, timeout=600)

        if result["returncode"] != 0 and "No results" not in result["stdout"]:
            # Write error to file for audit trail
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(f"[!] ffuf execution failed\n")
                f.write(f"Command: {cmd}\n")
                f.write(f"Exit code: {result['returncode']}\n\n")
                f.write(f"STDERR:\n{result['stderr']}\n\n")
                f.write(f"STDOUT:\n{result['stdout']}\n")

            return {
                "error": f"ffuf execution failed: {result['stderr']}",
                "outputFile": str(output_file)
            }

        # Write output to local file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(result["stdout"])

        # Parse the output
        summary = parse_ffuf_output(result["stdout"])

        # Generate human-readable message
        found_count = len(summary["discovered"])

        message = f"[+] ffuf scan complete (VPS: kali-pentest container)\n"
        message += f"    Target: {target}\n"
        message += f"    Wordlist: {wordlist}\n"
        message += f"    Discovered: {found_count} paths\n"

        if summary["discovered"][:5]:  # Show first 5
            message += f"    Top results:\n"
            for item in summary["discovered"][:5]:
                message += f"      [{item['status']}] {item['path']} ({item['size']} bytes)\n"

        if found_count > 5:
            message += f"      ... and {found_count - 5} more\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except Exception as e:
        # Write error to file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(f"[!] ffuf wrapper error\n")
            f.write(f"Error: {str(e)}\n")

        return {
            "error": f"ffuf execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_ffuf_output(content: str) -> Dict:
    """
    Parse ffuf output and extract discovered paths.

    Returns:
        Dict with discovered paths, status codes, sizes
    """

    discovered = []

    # ffuf output format varies, but typically shows:
    # path                    [Status: 200, Size: 1234, Words: 56, Lines: 78]
    pattern = r'(\S+)\s+\[Status:\s*(\d+),\s*Size:\s*(\d+)'

    for line in content.split('\n'):
        match = re.search(pattern, line)
        if match:
            discovered.append({
                "path": match.group(1),
                "status": int(match.group(2)),
                "size": int(match.group(3))
            })

    # Sort by status code, then by path
    discovered.sort(key=lambda x: (x['status'], x['path']))

    return {
        "discovered": discovered,
        "total": len(discovered),
        "statusCodes": list(set(d['status'] for d in discovered))
    }


if __name__ == "__main__":
    # CLI usage for testing
    if len(sys.argv) < 2:
        print("Usage: python ffuf.py <target_url> [wordlist] [options] [engagement_dir]")
        print("Example: python ffuf.py https://example.com/FUZZ")
        print("Example: python ffuf.py https://example.com/FUZZ /usr/share/wordlists/dirb/big.txt '-mc 200,301'")
        sys.exit(1)

    target = sys.argv[1]
    wordlist = sys.argv[2] if len(sys.argv) > 2 else "/usr/share/wordlists/dirb/common.txt"
    options = sys.argv[3] if len(sys.argv) > 3 else ""
    engagement_dir = sys.argv[4] if len(sys.argv) > 4 else None

    result = ffuf(target, wordlist, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
