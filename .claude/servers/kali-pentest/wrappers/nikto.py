#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
nikto wrapper - MCP Code API Pattern (VPS Docker deployment)
Executes nikto, saves raw output, returns parsed summary
"""

import sys
import io
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for utils
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.vps_utils import docker_exec

# Force UTF-8 encoding for Windows console output
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


def nikto(target: str, options: str = "", engagement_dir: Optional[str] = None) -> Dict:
    """
    Execute nikto web server vulnerability scanning.

    Args:
        target: Target URL/IP
        options: Additional nikto options
        engagement_dir: Optional engagement directory path

    Returns:
        Dict with:
        - summary: Parsed findings (critical issues, server info)
        - outputFile: Path to raw nikto output
        - message: Human-readable summary
    """

    # Generate output filename
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    safe_target = target.replace("/", "_").replace(":", "_").replace(".", "_")
    filename = f"{safe_target}-{timestamp}.txt"

    # Determine output directory
    if engagement_dir:
        output_dir = Path(engagement_dir) / "03-vulnerability-assessment" / "nikto"
    else:
        session_date = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path.home() / ".claude" / "sessions" / session_date / "scans" / "nikto"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / filename

    # Execute nikto
    cmd = f"nikto -h {target} {options} -o {output_file} -Format txt"

    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=900  # 15 minute timeout
        )

        # nikto returns non-zero even on success, check for output file
        if not output_file.exists():
            return {
                "error": f"nikto execution failed: {result["stderr"]}",
                "outputFile": str(output_file)
            }

        # Parse the output
        summary = parse_nikto_output(output_file)

        # Generate message
        total = summary["totalFindings"]
        message = f"[+] nikto scan complete\n"
        message += f"    Target: {target}\n"
        message += f"    Findings: {total}\n"

        if summary["serverInfo"]:
            message += f"    Server: {summary['serverInfo']}\n"

        if summary["criticalFindings"]:
            message += f"    Critical issues ({len(summary['criticalFindings'])}):\n"
            for finding in summary["criticalFindings"][:5]:
                message += f"      - {finding}\n"

        if summary["informationalFindings"]:
            message += f"    Informational: {len(summary['informationalFindings'])}\n"

        message += f"    Full results: {output_file}"

        return {
            "summary": summary,
            "outputFile": str(output_file),
            "message": message
        }

    except subprocess.TimeoutExpired:
        return {
            "error": "nikto timed out (15 minutes)",
            "outputFile": str(output_file)
        }
    except Exception as e:
        return {
            "error": f"nikto execution error: {str(e)}",
            "outputFile": str(output_file)
        }


def parse_nikto_output(filepath: Path) -> Dict:
    """Parse nikto text output file."""

    if not filepath.exists():
        return {
            "totalFindings": 0,
            "serverInfo": "",
            "criticalFindings": [],
            "informationalFindings": []
        }

    server_info = ""
    critical_findings = []
    informational_findings = []

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Extract server information
    server_match = re.search(r'\+ Server: (.+)', content)
    if server_match:
        server_info = server_match.group(1).strip()

    # Extract findings (lines starting with +)
    for line in content.split('\n'):
        line = line.strip()
        if line.startswith('+ '):
            finding = line[2:].strip()

            # Categorize findings
            if any(keyword in finding.lower() for keyword in [
                'vuln', 'exploit', 'injection', 'xss', 'csrf',
                'directory listing', 'default', 'admin', 'backdoor'
            ]):
                critical_findings.append(finding)
            elif finding and not finding.startswith('Target'):
                informational_findings.append(finding)

    total = len(critical_findings) + len(informational_findings)

    return {
        "totalFindings": total,
        "serverInfo": server_info,
        "criticalFindings": critical_findings,
        "informationalFindings": informational_findings
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python nikto.py <target> [options] [engagement_dir]")
        print("Example: python nikto.py https://example.com")
        print("Example: python nikto.py 192.168.1.1 '-ssl -p 443'")
        sys.exit(1)

    target = sys.argv[1]
    options = sys.argv[2] if len(sys.argv) > 2 else ""
    engagement_dir = sys.argv[3] if len(sys.argv) > 3 else None

    result = nikto(target, options, engagement_dir)

    if "error" in result:
        print(f"[!] Error: {result['error']}")
        sys.exit(1)
    else:
        print(result["message"])
