#!/usr/bin/env python3
"""
PostToolUse Hook: Audit Logging for Pentest Commands

Trigger: PostToolUse when tool_name == 'Bash'
Purpose: Log all Bash commands during pentest engagements for compliance

Detects pentest engagement context and logs:
- Command executed
- Full output
- Exit code
- Timestamps with SHA256 hashes

Output: Silent (writes to engagement audit-logs/, no stdout injection)
"""

import json
import sys
import os
import re
from pathlib import Path
from datetime import datetime

# Add tools directory to path for imports
FRAMEWORK_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(FRAMEWORK_ROOT))

try:
    from tools.security.audit_logger import (
        log_command,
        detect_pentest_engagement,
        is_audit_enabled
    )
except ImportError as e:
    # Graceful fallback if audit_logger not available
    print(f"WARNING: audit_logger import failed: {e}", file=sys.stderr)
    sys.exit(0)


# Security tool detection patterns
SECURITY_TOOLS = {
    # Network scanning
    "nmap": "network_discovery",
    "masscan": "network_discovery",
    "rustscan": "network_discovery",

    # Vulnerability scanning
    "nuclei": "vuln_scanning",
    "nikto": "vuln_scanning",
    "wpscan": "vuln_scanning",
    "sqlmap": "exploitation",

    # Web testing
    "ffuf": "web_fuzzing",
    "gobuster": "web_fuzzing",
    "feroxbuster": "web_fuzzing",
    "burp": "web_testing",
    "httpx": "web_testing",

    # Exploitation
    "msfconsole": "exploitation",
    "metasploit": "exploitation",
    "searchsploit": "exploit_research",

    # Credential testing
    "hydra": "credential_testing",
    "crackmapexec": "credential_testing",
    "netexec": "credential_testing",
    "impacket": "credential_testing",

    # Reconnaissance
    "subfinder": "recon",
    "amass": "recon",
    "theHarvester": "recon",
    "dnsx": "recon",

    # Cloud security
    "prowler": "cloud_security",
    "scoutsuite": "cloud_security",

    # Container security
    "trivy": "container_security",
    "grype": "container_security",
}


def detect_tool(command: str) -> tuple:
    """
    Detect security tool from command.

    Returns:
        Tuple of (tool_name, category) or (None, None)
    """
    # Extract first word/command
    parts = command.strip().split()
    if not parts:
        return None, None

    cmd = parts[0].lower()

    # Direct match
    if cmd in SECURITY_TOOLS:
        return cmd, SECURITY_TOOLS[cmd]

    # Check if command contains tool name
    command_lower = command.lower()
    for tool, category in SECURITY_TOOLS.items():
        if tool in command_lower:
            return tool, category

    # Docker-based tool detection
    if "docker" in command_lower:
        for tool, category in SECURITY_TOOLS.items():
            if tool in command_lower:
                return f"docker:{tool}", category

    return None, None


def extract_target(command: str) -> str:
    """
    Extract target from command (IP, domain, URL).

    Returns:
        Target string or None
    """
    # IP address pattern
    ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?\b'
    ip_match = re.search(ip_pattern, command)
    if ip_match:
        return ip_match.group()

    # Domain pattern (simplified)
    domain_pattern = r'\b(?:https?://)?([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}\b'
    domain_match = re.search(domain_pattern, command)
    if domain_match:
        return domain_match.group()

    return None


def find_engagement_dir(working_dir: str) -> str:
    """
    Find engagement directory from working directory or environment.

    Checks:
    1. Environment variable PENTEST_ENGAGEMENT_DIR
    2. Current/parent directories for SCOPE.md
    3. Known engagement paths pattern

    Returns:
        Engagement directory path or None
    """
    # Check environment variable first
    env_dir = os.environ.get("PENTEST_ENGAGEMENT_DIR")
    if env_dir and Path(env_dir).exists():
        return env_dir

    # Check working directory and parents
    check_path = Path(working_dir)
    for _ in range(6):  # Check up to 6 levels
        if (check_path / "SCOPE.md").exists():
            return str(check_path)

        # Check for pentest engagement pattern
        if "pentests" in str(check_path) or "engagements" in str(check_path):
            if (check_path / "SCOPE.md").exists():
                return str(check_path)

        parent = check_path.parent
        if parent == check_path:
            break
        check_path = parent

    return None


def main():
    """Process Bash tool PostToolUse event for audit logging."""
    try:
        # Read hook data from stdin
        data = json.load(sys.stdin)

        # Extract tool info
        tool_name = data.get("tool_name", "")

        # Only process Bash tool
        if tool_name != "Bash":
            sys.exit(0)

        # Extract parameters and result
        parameters = data.get("parameters", {})
        result = data.get("result", {})

        command = parameters.get("command", "")
        working_dir = parameters.get("cwd", os.getcwd())

        # Get result info
        stdout = result.get("stdout", "")
        stderr = result.get("stderr", "")
        exit_code = result.get("exit_code", 0)
        duration_ms = result.get("duration_ms", 0)

        # Combine output
        output = stdout
        if stderr:
            output += f"\n--- STDERR ---\n{stderr}"

        # Detect if this is a security tool
        detected_tool, category = detect_tool(command)

        # Find engagement directory
        engagement_dir = find_engagement_dir(working_dir)

        # If no engagement found and not a security tool, skip
        if not engagement_dir and not detected_tool:
            sys.exit(0)

        # If engagement found but audit disabled, skip
        if engagement_dir and not is_audit_enabled(engagement_dir):
            sys.exit(0)

        # If no engagement but security tool detected, try to find one
        if not engagement_dir and detected_tool:
            # Check if there's an active pentest engagement
            engagement_dir = detect_pentest_engagement()

        # Final check - if still no engagement, skip
        if not engagement_dir:
            sys.exit(0)

        # Extract target from command
        target = extract_target(command)

        # Log the command
        log_command(
            engagement_dir=engagement_dir,
            command=command,
            output=output,
            exit_code=exit_code,
            tool=detected_tool or "bash",
            target=target,
            category=category or "shell",
            scope_verified=True,  # Assume verified (SCOPE.md check already done)
            duration_ms=duration_ms
        )

        # Silent exit - don't inject anything into conversation
        sys.exit(0)

    except json.JSONDecodeError as e:
        # Fail gracefully
        print(f"WARNING: Hook JSON parse error: {e}", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        # Fail gracefully - never block the Bash tool
        print(f"WARNING: Audit hook error: {e}", file=sys.stderr)
        sys.exit(0)


if __name__ == "__main__":
    main()
